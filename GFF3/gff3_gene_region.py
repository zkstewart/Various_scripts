#! python3
# gff3_gene_region.py
# Script to perform extraction of genomic regions associated
# with one or more genes as specified via text file input

import os, argparse, sys
from Bio import SeqIO

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from Function_packages import ZS_GFF3IO

# Define functions for later use
## Validate arguments
def validate_args(args):
    # Validate input file locations
    if not os.path.isfile(args.fasta):
        print('I am unable to locate the genome fasta file (' + args.fasta + ')')
        print('Make sure you\'ve typed the file name or location correctly and try again.')
        quit()
    if not os.path.isfile(args.gff3File):
        print('I am unable to locate the gene model GFF3 file (' + args.gff3File + ')')
        print('Make sure you\'ve typed the file name or location correctly and try again.')
        quit()
    if args.textFile != None:
        if not os.path.isfile(args.textFile):
            print('I am unable to locate the text file (' + args.textFile + ')')
            print('Make sure you\'ve typed the file name or location correctly and try again.')
            quit()
    # Validate numeric inputs
    if args.borderSize < 0:
        print("borderSize must be an integer no less than 0")
    # Handle file overwrites
    if os.path.isfile(args.outputFileName):
        print(args.outputFileName + ' already exists. Delete/move/rename this file and run the program again.')
        quit()

def text_file_to_list(textFile):
    outList = []
    with open(textFile, 'r') as fileIn:
        for line in fileIn:
            outList.append(line.rstrip('\r\n'))
    return outList

def longest_iso(mrnaFeatures):
    '''
    This function was ripped from gff3_to_fasta.py...
    '''
    longestMrna = [None, 0]
    for feature in mrnaFeatures:
        mrnaLen = 0
        
        if hasattr(feature, "CDS"):
            featType = "CDS"
        elif hasattr(feature, "exon"):
            featType = "exon"
        else:
            continue # no CDS or exon means this feature cannot be used
        
        for subFeature in feature.__dict__[featType]:
            
            mrnaLen += (subFeature.end - subFeature.start + 1)
            
        if mrnaLen > longestMrna[1]:
            longestMrna = [feature, mrnaLen]
        
    mrnaList = [longestMrna[0]]
    return mrnaList

def extract_genomic_region(coordsList, genomeRecords, contigID):
    '''
    Extracts the genomic sequence associated with a set of coordinates.
    
    Parameters:
        coordsList -- a list of lists with structure like:
                      [
                          [coord1, coord2], # these are integers
                          [coord3, coord4],
                          ...
                      ]
        genomeRecords -- a dictionary generated by Bio.SeqIO.to_dict()
        contigID -- a string used to locate the Seq object in genomeRecords
    '''
    contigString = str(genomeRecords[contigID].seq)
    
    sequence = ""
    for start, end in sorted(coordsList, key = lambda x: (x[0], x[1])):
        sequence += contigString[start-1:end]
    return sequence

def main():
    ##### USER INPUT SECTION
    usage = """%(prog)s reads in a GFF3 file in addition to a text file listing gene IDs
    containing coordinates for which the encompassed region should be extracted. This
    script allows two modes, the first being where introns are removed, and the second
    being where they are kept in.
    """
    # Required
    p = argparse.ArgumentParser(description=usage)
    p.add_argument("-i", "-input", dest="fasta",
                   required=True,
                   help="Genome fasta file")
    p.add_argument("-g", "-gff3", dest="gff3File",
                   required=True,
                   help="Specify the gene model GFF3 file.")
    p.add_argument("-o", "-outputFile", dest="outputFileName",
                   required=True,
                   help="Output file name.")
    # Optional
    p.add_argument("--textFile", dest="textFile",
                   required=False,
                   help="""Optionally, specify a text file listing gene IDs to limit
                   region extraction to just those gene IDs""")
    p.add_argument("--borderSize", dest="borderSize",
                   required=False,
                   type=int,
                   help="""Optionally, specify how much sequence from up and
                   downstream of the gene borders you want to obtain.""",
                   default=0)
    p.add_argument("--keepIntrons", dest="keepIntrons",
                   required=False,
                   action="store_true",
                   help="Specify this flag to keep introns in the extracted region")
    p.add_argument("--borderOnlyStart", dest="borderOnlyStart",
                   required=False,
                   action="store_true",
                   help="Specify this flag to only add the border to the start site")
    p.add_argument("--getExons", dest="getExons",
                   required=False,
                   action="store_true",
                   help="Specify this flag to use exon coords, not CDS coords")
    
    args = p.parse_args()
    validate_args(args)
    
    # Parse annotation GFF3
    GFF3_obj = ZS_GFF3IO.GFF3(args.gff3File, strict_parse=False)
    
    # Load the fasta file and parse its contents
    genomeRecords = SeqIO.to_dict(SeqIO.parse(args.fasta, 'fasta'))
    
    # Parse text file
    if args.textFile != None:
        idList = text_file_to_list(args.textFile)
    else:
        idList = [ f.ID for f in GFF3_obj.types["gene"] ]
    
    # Produce output file
    with open(args.outputFileName, "w") as fileOut:
        for id in idList:
            # Validate that this ID exists
            if not id in GFF3_obj:
                raise KeyError(f"{id} not found in your GFF3!")
            
            contigID = GFF3_obj[id].contig
            
            # Get coordinates if introns are desired
            if args.keepIntrons:
                coords = [GFF3_obj[id].coords] # need this to be a list of lists
            
            # Otherwise, get coordinates for intron removed sequence
            else:
                mrnaFeature = longest_iso(GFF3_obj[id].mRNA)[0]
                if args.getExons:
                    coords, _, _ = GFF3_obj.retrieve_coords(mrnaFeature, "exon")
                else:
                    coords, _, _ = GFF3_obj.retrieve_coords(mrnaFeature, "CDS")
            
            # Add border if relevant
            coords.sort(key = lambda x: (x[0], x[1])) # make sure it's sorted first
            if args.borderSize > 0:
                if not args.borderOnlyStart or (args.borderOnlyStart and GFF3_obj[id].strand == "+"):
                    coords[0][0] -= args.borderSize
                    coords[0][0] = coords[0][0] if coords[0][0] > 0 else 1
                
                if not args.borderOnlyStart or (args.borderOnlyStart and GFF3_obj[id].strand == "-"):
                    coords[-1][1] += args.borderSize
                    coords[-1][1] = coords[-1][1] if coords[-1][1] <= len(genomeRecords[contigID]) \
                        else len(genomeRecords[contigID])
            
            # Extract the sequence
            sequence = extract_genomic_region(coords, genomeRecords, contigID)
            
            # Write it to file
            fileOut.write(f">{id} start={coords[0][0]} end={coords[-1][1]} " +
                          f"hasIntrons={args.keepIntrons}\n{sequence}\n")
    
    # All done!
    print('Program completed successfully!')

if __name__ == "__main__":
    main()
