#! python3
# get_haplotype_seq.py
# Script to find the top X haplotype variants as discovered by
# PHASE frequencies and, with relation to the reference sequence and
# the variants VCF generated by GATK, output these haplotype sequences
# to FASTA.

import os, argparse, re
from Bio import SeqIO
from copy import deepcopy

# Define functions
def validate_args(args):
    # Validate that all arguments have been provided
    for key, value in vars(args).items():
        if value == None:
            print(key + ' argument was not specified. Fix this and try again.')
            quit()
    # Validate input file locations
    if not os.path.isfile(args.vcf):
        print('I am unable to locate the VCF file (' + args.vcf + ')')
        print('Make sure you\'ve typed the file name or location correctly and try again.')
        quit()
    if not os.path.isfile(args.phase):
        print('I am unable to locate the PHASE freqs file (' + args.phase + ')')
        print('Make sure you\'ve typed the file name or location correctly and try again.')
        quit()
    if not os.path.isfile(args.gff3):
        print('I am unable to locate the GFF3 annotation file (' + args.gff3 + ')')
        print('Make sure you\'ve typed the file name or location correctly and try again.')
        quit()
    if not os.path.isfile(args.genomeFasta):
        print('I am unable to locate the genome FASTA file (' + args.genomeFasta + ')')
        print('Make sure you\'ve typed the file name or location correctly and try again.')
        quit()
    # Validate output file location
    if os.path.isfile(args.outputFileName):
        print('File already exists at output location (' + args.outputFileName + ')')
        print('Make sure you specify a unique file name and try again.')
        quit()

class Gff3:
        def __init__(self, file_location):
                self.file_location = file_location
                self.gene_dict = {} # Our output structure will have 1 entry per gene which is stored in here
                self.index_dict = {} # The index_dict will wrap the gene_dict and index gene IDs and mRNA ID's to the shared single entry per gene ID
                self.id_values = {'main': {}, 'feature': {}} # This will contain as many key:value pairs as there are main types (e.g., gene/pseudogene/ncRNA_gene) and feature types (e.g., mRNA/tRNA/rRNA)
                self.contig_values = []
                self.parse_gff3()
        
        ## Parsing
        def parse_gff3(self):
                # Gene object loop
                with open(self.file_location, 'r') as file_in:
                        for line in file_in:
                                line = line.replace('\r', '') # Get rid of return carriages immediately so we can handle lines like they are Linux-formatted
                                # Skip filler and comment lines
                                if line == '\n' or line.startswith('#'):
                                        continue
                                # Get details
                                sl = line.rstrip('\n').split('\t')
                                line_type = sl[2]
                                details = sl[8].split(';')
                                detail_dict = {}
                                for i in range(len(details)):
                                        if details[i] == '':
                                                continue
                                        split_details = details[i].split('=', maxsplit=1)
                                        detail_dict[split_details[0]] = split_details[1]
                                self.contig_values.append(sl[0])
                                # Build gene group dict objects
                                if 'Parent' not in detail_dict: # If there is no Parent field in the details, this should BE the parent structure
                                        if 'ID' not in detail_dict: # Parent structures should also have ID= fields - see the human genome GFF3 biological_region values for why this is necessary
                                                continue
                                        if detail_dict['ID'] not in self.gene_dict:
                                                # Create entry
                                                self.gene_dict[detail_dict['ID']] = {'attributes': {}}
                                                # Add attributes
                                                for k, v in detail_dict.items():
                                                        self.gene_dict[detail_dict['ID']]['attributes'][k] = v
                                                # Add all other gene details
                                                self.gene_dict[detail_dict['ID']]['contig_id'] = sl[0]
                                                self.gene_dict[detail_dict['ID']]['source'] = sl[1]
                                                self.gene_dict[detail_dict['ID']]['feature_type'] = sl[2]
                                                self.gene_dict[detail_dict['ID']]['coords'] = [int(sl[3]), int(sl[4])]
                                                self.gene_dict[detail_dict['ID']]['score'] = sl[5]
                                                self.gene_dict[detail_dict['ID']]['orientation'] = sl[6]
                                                self.gene_dict[detail_dict['ID']]['frame'] = sl[7]
                                                # Index in self.index_dict & idValues & geneIdValues
                                                self.index_dict[detail_dict['ID']] = self.gene_dict[detail_dict['ID']]
                                                if line_type not in self.id_values['main']:
                                                        self.id_values['main'][line_type] = [detail_dict['ID']]
                                                else:
                                                        self.id_values['main'][line_type].append(detail_dict['ID'])
                                                # Add extra details
                                                self.gene_dict[detail_dict['ID']]['feature_list'] = [] # This provides us a structure we can iterate over to look at each feature within a gene entry
                                                continue
                                        else:
                                                print('Gene ID is duplicated in your GFF3! "' + detail_dict['ID'] + '" occurs twice within ID= field. File is incorrectly formatted and can\'t be processed, sorry.')
                                                print('For debugging purposes, the line == ' + line)
                                                print('Program will exit now.')
                                                quit()
                                # Handle subfeatures within genes
                                if detail_dict['Parent'] in self.gene_dict:
                                        parents = [detail_dict['Parent']]
                                else:
                                        parents = detail_dict['Parent'].split(',')
                                for parent in parents:
                                        # Handle primary subfeatures (e.g., mRNA/tRNA/rRNA/etc.) / handle primary features (e.g., protein) that behave like primary subfeatures
                                        if parent in self.gene_dict and ('ID' in detail_dict or ('ID' not in detail_dict and parent not in self.gene_dict[parent])): # The last 'and' clause means we only do this once for proceeding into the next block of code
                                                if 'ID' in detail_dict:
                                                        id_index = detail_dict['ID']
                                                else:
                                                        id_index = parent
                                                self.gene_dict[parent][id_index] = {'attributes': {}}
                                                # Add attributes
                                                for k, v in detail_dict.items():
                                                        self.gene_dict[parent][id_index]['attributes'][k] = v
                                                # Add all other gene details
                                                self.gene_dict[parent][id_index]['contig_id'] = sl[0]
                                                self.gene_dict[parent][id_index]['source'] = sl[1]
                                                self.gene_dict[parent][id_index]['feature_type'] = sl[2]
                                                self.gene_dict[parent][id_index]['coords'] = [int(sl[3]), int(sl[4])]
                                                self.gene_dict[parent][id_index]['score'] = sl[5]
                                                self.gene_dict[parent][id_index]['orientation'] = sl[6]
                                                self.gene_dict[parent][id_index]['frame'] = sl[7]
                                                # Index in self.index_dict & idValues
                                                self.index_dict[id_index] = self.gene_dict[parent]
                                                if line_type not in self.id_values['feature']:
                                                        self.id_values['feature'][line_type] = [id_index]
                                                else:
                                                        self.id_values['feature'][line_type].append(id_index)
                                                # Add extra details to this feature
                                                self.gene_dict[parent]['feature_list'].append(id_index)
                                                if 'ID' in detail_dict:  # We don't need to proceed into the below code block if we're handling a normal primary subfeature; we do want to continue if it's something like a protein that behaves like a primary subfeature despite being a primary feature
                                                        continue
                                        # Handle secondary subfeatures (e.g., CDS/exon/etc.)
                                        if parent not in self.index_dict:
                                                print(line_type + ' ID not identified already in your GFF3! "' + parent + '" occurs within Parent= field without being present within an ID= field first. File is incorrectly formatted and can\'t be processed, sorry.')
                                                print('For debugging purposes, the line == ' + line)
                                                print('Program will exit now.')
                                                quit()
                                        elif parent not in self.index_dict[parent]:
                                                print(line_type + ' ID does not map to a feature in your GFF3! "' + parent + '" occurs within Parent= field without being present as an ID= field with its own Parent= field on another line first. File is incorrectly formatted and can\'t be processed, sorry.')
                                                print('For debugging purposes, the line == ' + line)
                                                print('Program will exit now.')
                                                quit()
                                        else:
                                                # Create/append to entry
                                                if line_type not in self.index_dict[parent][parent]:
                                                        # Create entry
                                                        self.index_dict[parent][parent][line_type] =  {'attributes': [{}]}
                                                        # Add attributes
                                                        for k, v in detail_dict.items():
                                                                self.index_dict[parent][parent][line_type]['attributes'][-1][k] = v # We need to do it this way since some GFF3 files have comments on only one CDS line and not all of them
                                                        # Add all other line_type-relevant details
                                                        self.index_dict[parent][parent][line_type]['coords'] = [[int(sl[3]), int(sl[4])]]
                                                        self.index_dict[parent][parent][line_type]['score'] = [sl[5]]
                                                        self.index_dict[parent][parent][line_type]['frame'] = [sl[7]]
                                                        # Add extra details to this feature
                                                        if 'feature_list' not in self.index_dict[parent][parent]:
                                                                self.index_dict[parent][parent]['feature_list'] = [line_type]
                                                        else:
                                                                self.index_dict[parent][parent]['feature_list'].append(line_type)
                                                else:
                                                        # Add attributes
                                                        self.index_dict[parent][parent][line_type]['attributes'].append({})
                                                        for k, v in detail_dict.items():
                                                                self.index_dict[parent][parent][line_type]['attributes'][-1][k] = v # By using a list, we have an ordered set of attributes for each line_type
                                                        # Add all other line_type-relevant details
                                                        self.index_dict[parent][parent][line_type]['coords'].append([int(sl[3]), int(sl[4])])
                                                        self.index_dict[parent][parent][line_type]['score'].append(sl[5])
                                                        self.index_dict[parent][parent][line_type]['frame'].append(sl[7])
                # Generate shortcut attributes
                self.gene_values = self.id_values['main']['gene']
                self.mrna_values = self.id_values['feature']['mRNA']
                self.primary_values = [feature for featureList in self.id_values['main'].values() for feature in featureList]
                self.secondary_values = [feature for featureList in self.id_values['feature'].values() for feature in featureList]
                # Sort contig_values
                self.contig_values = list(set(self.contig_values))
                try:
                        self.contig_values.sort(key = lambda x: list(map(int, re.findall(r'\d+', x)))) # This should let us sort things like "contig1a2" and "contig1a1" and have the latter come first
                except:
                        self.contig_values.sort() # This is a bit crude, but necessary in cases where contigs lack numeric characters

def parse_phase_freqs(phaseFile, numToRetrieve):
    # Parse file
    haplotypes = []
    with open(phaseFile, "r") as fileIn:
        for line in fileIn:
            sl = line.strip().split()
            # Skip header line
            if sl[0] == "index":
                continue
            # Add to list
            haplotypes.append([sl[1], float(sl[2])]) # [haplotype, freq]
    haplotypes.sort(key = lambda x: -x[1])

    # Return
    return haplotypes[0: numToRetrieve]

def parse_vcf(vcfFile):
    vcfDict = {}
    with open(vcfFile, "r") as fileIn:
        for line in fileIn:
            if line.startswith("#"):
                continue
            # Get relevant details
            sl = line.split("\t")
            contig = sl[0]
            pos = int(sl[1])
            ref = sl[3]
            alt = sl[4].split(",")
            # Store in dict
            if contig not in vcfDict:
                vcfDict[contig] = [[pos, ref, alt]]
            else:
                vcfDict[contig].append([pos, ref, alt])
    return vcfDict

def gff3_object_haplotype_extract(gff3Object, mrna, genomeRecords, seqType, vcfDict, haplotype): # gff3Object should be produced by the Gff3 class; mrna is a string which should correspond to a subfeature key in the Gff3.index_dict; genomeRecords should be a Biopython SeqIO.parse() object of the genome's contigs
        # Setup
        cdsWarning = False
        # Ensure that seqType is sensible
        seqType = seqType.lower()
        if seqType not in ['transcript', 'cds', 'both']:
                print('gff3_index_sequence_extract: seqType value is not sensible; you need to fix the inputs to this function.')
                quit()
        # Obtain the indexed gene object
        value = gff3Object.index_dict[mrna]
        # Retrieve genomic sequence
        try:
                genomeSeq = str(genomeRecords[value['contig_id']].seq)
        except:
                print('Contig ID "' + value['contig_id'] + '" is not present in your FASTA file; mRNA ID "' + mrna + '" cannot be handled.')
                print('This represents a major problem with your inputs, so I\'m going to stop processing now. Make sure you are using the correct FASTA file and try again.')
                quit()
        # Get the longest isoform for this gene
        mrna = longest_iso(value)[0]
        # Sort coords lists for consistency [this can be relevant since not all GFF3's are ordered equivalently]
        ## Exon coords
        if value[mrna]['orientation'] == '+':
                value[mrna]['exon']['coords'].sort(key = lambda x: (int(x[0]), int(x[1])))
        elif value[mrna]['orientation'] == '-':
                value[mrna]['exon']['coords'].sort(key = lambda x: (-int(x[0]), -int(x[1])))
        ## CDS coords
        if 'CDS' in value[mrna]: # This check here (and below) is a way of ensuring that we only produce CDS outputs for features that are annotated as coding in the GFF3 file
                cdsSort = list(zip(value[mrna]['CDS']['coords'], value[mrna]['CDS']['frame']))
                if value[mrna]['orientation'] == '+':
                        cdsSort.sort(key = lambda x: (int(x[0][0]), int(x[0][1])))
                        value[mrna]['CDS']['coords'] = [coord for coord,frame in cdsSort]
                        value[mrna]['CDS']['frame'] = [frame for coord,frame in cdsSort]
                elif value[mrna]['orientation'] == '-':
                        cdsSort.sort(key = lambda x: (-int(x[0][0]), -int(x[0][1])))
                        value[mrna]['CDS']['coords'] = [coord for coord,frame in cdsSort]
                        value[mrna]['CDS']['frame'] = [frame for coord,frame in cdsSort]
                else:
                        print(mrna + ' lacks proper orientation specification within GFF3 (it is == "' + str(value[mrna]['orientation']) + '"; this may result in problems.')
        elif cdsWarning == False and seqType == 'both':
                print('Warning: there are \'gene\' features which lack CDS subfeatures; your .trans file will contain more entries than .aa or .nucl files.')
                cdsWarning = True
        # Reverse the coord lists if we're looking at a '-' model so we start at the 3' end of the gene model
        if value['orientation'] == '-':
                value[mrna]['exon']['coords'].reverse()
                if 'CDS' in value[mrna]:
                        value[mrna]['CDS']['coords'].reverse()
        # Edit genomic sequence if needed
        genomeSeq = vcf_edit_sequence(vcfDict, value, mrna, genomeSeq, haplotype)
        # Join sequence segments
        if seqType == 'transcript' or seqType == 'both':
                transcript = ''
                for coord in value[mrna]['exon']['coords']:
                        segment = genomeSeq[int(coord[0])-1:int(coord[1])] # Make it 1-based by -1 to the first coordinate
                        transcript += segment
                # Reverse comp if necessary
                if value['orientation'] == '-':
                        transcript = reverse_comp(transcript)
        if seqType == 'cds' or seqType == 'both':
                cds = None      # This lets us return something when CDS doesn't exist
                if 'CDS' in value[mrna]:
                        cds = ''
                        for coord in value[mrna]['CDS']['coords']:
                                segment = genomeSeq[int(coord[0])-1:int(coord[1])] # Make it 1-based by -1 to the first coordinate
                                cds += segment
                        # Reverse comp if necessary
                        if value['orientation'] == '-':
                                cds = reverse_comp(cds)
        # Return transcript and/or CDS sequence
        if seqType == 'transcript':
                return transcript
        elif seqType == 'cds':
                return cds
        elif seqType == 'both':
                return transcript, cds

def longest_iso(geneDictObj):
        longestMrna = ['', 0]           # We pick out the representative gene based on length. If length is identical, we'll end up picking the entry listed first in the gff3 file since our > condition won't be met. I doubt this will happen much or at all though.
        for mrna in geneDictObj['feature_list']:
                mrnaLen = 0
                if 'CDS' in geneDictObj[mrna]:
                        featType = 'CDS'
                else:
                        featType = 'exon'
                for coord in geneDictObj[mrna][featType]['coords']:
                        mrnaLen += (int(coord[1]) - int(coord[0]) + 1)
                if mrnaLen > longestMrna[1]:
                        longestMrna = [mrna, mrnaLen]
        mrnaList = [longestMrna[0]]
        return mrnaList

def vcf_edit_sequence(vcfDict, gff3Value, mrnaID, genomeSeq, haplotype): # mrnaValue should be the result of a gff3Object entry with [mrna] indexed
        contigID = gff3Value['contig_id']
        if contigID in vcfDict:
                # Format edit positions list
                vcfList = vcfDict[contigID]
                vcfList.sort(reverse=True)
                haplotype = haplotype[0][::-1]
                # Edit the genome sequence
                for i in range(len(vcfList)):
                        edit = vcfList[i]
                        hapValue = int(haplotype[i])
                        indelIndex = edit[0] - 1                                        # - 1 to make this act 0-based (in the main program we instead minused coordRange which accomplished the same goal of making the index 0-based).
                        if hapValue != 0: # if hapValue == 0, it's just the reference
                            refResidue = edit[1]
                            editResidue = edit[2][hapValue - 1] # hapValue == 1 means we get the first value in our edit list
                            # Make edit
                            genomeSeq = genomeSeq[:indelIndex] + editResidue + genomeSeq[indelIndex+len(refResidue):]
                            # Update coords if necessary
                            if len(editResidue) != len(refResidue): # Skip irrelevant updates
                                vcf_edit_update_coords(indelIndex, refResidue, editResidue, gff3Value, mrnaID)
        return genomeSeq

def reverse_comp(seq):
        reversedSeq = seq[::-1].lower()
        # Decode characters
        reversedSeq = reversedSeq.replace('a', 'T')
        reversedSeq = reversedSeq.replace('t', 'A')
        reversedSeq = reversedSeq.replace('c', 'G')
        reversedSeq = reversedSeq.replace('g', 'C')
        return reversedSeq

def vcf_edit_update_coords(indelIndex, refResidue, editResidue, gff3Value, mrnaID): # We don't indelIndex this to be 0-based, 1-based is correct here
    # Extract relevant information
    lenDifference = len(editResidue) - len(refResidue)
    # Edit gene-level coords
    if indelIndex in range(gff3Value['coords'][0], gff3Value['coords'][1]+1):       # This should always be true?
            gff3Value['coords'][1] += lenDifference
    # Edit mrna-level coords
    if indelIndex in range(gff3Value[mrnaID]['coords'][0], gff3Value[mrnaID]['coords'][1]+1): # This should always be true?
            gff3Value[mrnaID]['coords'][1] += lenDifference
    # Edit exon-level coords
    cumulativeChange = 0 # Cumulative change will propagate length differences throughout coords as they occur in order 
    for i in range(len(gff3Value[mrnaID]['exon']['coords'])):
            # Make cumulative changes
            gff3Value[mrnaID]['exon']['coords'][i][0] += cumulativeChange
            gff3Value[mrnaID]['exon']['coords'][i][1] += cumulativeChange
            # Make edit-specific changes
            if indelIndex in range(gff3Value[mrnaID]['exon']['coords'][i][0], gff3Value[mrnaID]['exon']['coords'][i][1]+1):
                    gff3Value[mrnaID]['exon']['coords'][i][1] += lenDifference
                    cumulativeChange += lenDifference
    # Edit CDS-level coords
    cumulativeChange = 0
    if 'CDS' in gff3Value[mrnaID]:
            for i in range(len(gff3Value[mrnaID]['CDS']['coords'])):
                    # Make cumulative changes
                    gff3Value[mrnaID]['CDS']['coords'][i][0] += cumulativeChange
                    gff3Value[mrnaID]['CDS']['coords'][i][1] += cumulativeChange
                    # Make edit-specific changes
                    if indelIndex in range(gff3Value[mrnaID]['CDS']['coords'][i][0], gff3Value[mrnaID]['CDS']['coords'][i][1]+1):
                            gff3Value[mrnaID]['CDS']['coords'][i][1] += lenDifference
                            cumulativeChange += lenDifference

def main():
    # User input
    usage = """%(prog)s reads in a bunch of files specified below and will automatically
    generate a FASTA file of haplotype sequences incorporating the various variants.
    """
    p = argparse.ArgumentParser(description=usage)
    p.add_argument("-id", dest="geneID",
        help="Specify the ID of the gene to be extracted as FASTA sequence(s)")
    p.add_argument("-v", dest="vcf",
        help="Input VCF file name")
    p.add_argument("-p", dest="phase",
        help="Input PHASE frequencies file name")
    p.add_argument("-g", dest="gff3",
        help="Input GFF3 gene annotation file name")
    p.add_argument("-f", dest="genomeFasta",
        help="Input genome FASTA file name")
    p.add_argument("-o", dest="outputFileName",
        help="Output file name for the haplotype FASTA")
    p.add_argument("-X", dest="numHaplotypes", type=int, default=5,
        help="Optionally specify the number of top frequency haplotypes to produce sequences for (default=5)")
    args = p.parse_args()
    validate_args(args)

    # Parse PHASE freqs file
    haplotypes = parse_phase_freqs(args.phase, args.numHaplotypes)
    if haplotypes == []:
        # Exit gracefully for empty haplotype files
        emptyName = "{0}.no_haplotypes".format(args.outputFileName.rsplit(".", maxsplit=1)[0])
        with open(emptyName, "w") as fileOut:
            pass
        print("No haplotypes found; exiting now")
        quit()

    # Parse GATK VCF file
    vcfDict = parse_vcf(args.vcf)

    # Parse GFF3 for gene annotation
    gff3 = Gff3(args.gff3)
    assert args.geneID in gff3.index_dict

    # Load the genome FASTA file and parse its contents
    genomeRecords = SeqIO.to_dict(SeqIO.parse(open(args.genomeFasta, 'r'), 'fasta'))

    # Iteratively get our haplotype sequences
    sequences = []
    haplotypes.insert(0, ['0'*len(haplotypes[0][0]), "REFERENCE"])
    for haplotype in haplotypes:
        backup = deepcopy(gff3.index_dict[args.geneID])
        transcript, cds = gff3_object_haplotype_extract(gff3, args.geneID, genomeRecords, "both", vcfDict, haplotype)
        sequences.append(cds)
        gff3.index_dict[args.geneID] = backup # Don't carry over changes to the gff3 gene entry
    
    # Produce output FASTA
    with open(args.outputFileName, "w") as fileOut:
        for i in range(len(haplotypes)):
            haplotype = haplotypes[i]
            seq = sequences[i]
            seqid = ">{0}_seq{1} haplotypeCode={2} frequency={3}".format(args.geneID, i+1, haplotype[0], haplotype[1])
            fileOut.write("{0}\n{1}\n".format(seqid, seq))

if __name__ == "__main__":
    main()
