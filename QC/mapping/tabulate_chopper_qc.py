#! python3
# tabulate_chopper_qc.py
# Simple script to read in .e files generated by chopper
# and tabulate the results for easy understanding

import os, argparse, re

# Define functions
def validate_args(args):
    # Validate input file locations
    if not os.path.isdir(args.qcDir):
        print('I am unable to locate the parent directory where chopper stderr files are (' + args.qcDir + ')')
        print('Make sure you\'ve typed the file name or location correctly and try again.')
        quit()
    # Validate output file location
    if os.path.isfile(args.outputFileName):
        print('File already exists at output location (' + args.outputFileName + ')')
        print('Make sure you specify a unique file name and try again.')
        quit()

def get_qc_count_from_files(stderrFiles):
    '''
    Parameters:
        stderrFiles -- a list containing strings that point to stderr
                       files containing read QC values
    Returns:
        statsTable -- a list of lists with structure like:
                      [
                          [header_row_values],
                          [sample1, original_count, qc_count],
                          [sample2, original_count, qc_count],
                          ...
                      ]
    '''
    percentageRegex = re.compile(r"\d{1,3}\.\d{1,2}%")
    
    # Setup the output table format
    statsTable=["sample\toriginal_read_count\tqc_pass_count"]
    
    # Parse all logs files
    for file in stderrFiles:
        # Get the sample name from the file prefix
        sampleName = os.path.basename(file).split(".")[0]
        
        # Parse the file
        with open(file, "r") as fileIn:
            statsTable.append([sampleName])
            
            for line in fileIn:
                l = line.strip("\r\n ")
                if l.startswith("Kept "):
                    # Extract information from line and store it
                    sl = line.split(" ")
                    qcCount, originalCount = sl[1], sl[5]
                
                    statsTable[-1] += [originalCount, qcCount]
            statsTable[-1] = "\t".join(statsTable[-1])
    
    return statsTable

## Main
def main():
    # User input
    usage = """%(prog)s accepts a directory containing stderr files output from chopper
    and writes a condensed table of read QC values to the output file.
    """
    p = argparse.ArgumentParser(description=usage)
    # Required
    p.add_argument("-i", dest="qcDir",
                   required=True,
                   help="Input directory containing .flagstat files")
    p.add_argument("-o", dest="outputFileName",
                   required=True,
                   help="Output file name for the reads count table")
    # Optional
    p.add_argument("--suffix", dest="fileSuffix",
                   required=False,
                   help="""Specify the file suffix uniquely identifying
                   chopper stderr files (default == '.qc')""",
                   default=".qc")
    
    args = p.parse_args()
    validate_args(args)
    
    # Get chopper stderr files list
    stderrFiles = []
    for file in os.listdir(args.qcDir):
        if file.endswith(args.fileSuffix):
            stderrFiles.append(os.path.join(args.qcDir, file))
    
    # Combine .flagstat files
    statsTable = get_qc_count_from_files(stderrFiles)
    
    # Write output
    with open(args.outputFileName, "w") as fileOut:
        fileOut.write("\n".join(statsTable))
    
    # Alert user to program success
    print("Program completed successfully!")

if __name__ == "__main__":
    main()
