#! python3
# Script to navigate the annoyances of file uploading
# via Windows File Explorer and the errors that can lead
# to file upload interruption. It's detectable easily
# by checking the file on disk within file properties,
# but guess what's impossible to find with basic command
# line stuff? That. Fuck.

import os, time, ctypes
import ctypes.wintypes

import os, pyautogui, screeninfo, time, cv2, argparse, pytesseract
from PIL import Image
import numpy as np
from mss import mss

TEMPLATE_DIR = "template_images" # must be located in the same dir as this script

# Define functions
## Template-matching related
def take_screenshot(subsection_coords=None):
        '''subsection_coords specifies the range to screenshot; also, some code borrowed from
        https://www.tautvidas.com/blog/2018/02/automating-basic-tasks-in-games-with-opencv-and-python/
        Note that the width and height values that mss().grab() uses refers not to the
        actual coordinate value but merely the width FROM the left or height FROM
        the top coordinate.
        '''
        if subsection_coords == None:
                '''i.e., by default we capture the whole screen'''
                monitor = screeninfo.get_monitors()[0]
                grab_coords = {'left': monitor.x, 'top': monitor.y, 'width': monitor.width, 'height': monitor.height}
        else:
                grab_coords = {'left': subsection_coords[0], 'top': subsection_coords[1], 'width': subsection_coords[2], 'height': subsection_coords[3]}
        while True:
                try:
                        with mss() as sct:
                                screenshot_image = sct.grab(grab_coords)
                        break
                except:
                        time.sleep(1)
        img = Image.frombytes('RGB', screenshot_image.size, screenshot_image.rgb)
        img = np.array(img)
        img = img[:, :, ::-1]
        screenshot_grayscale = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        return screenshot_grayscale

def temp_file_prefix_gen(prefix, suffix):
        ongoingCount = 1
        while True:
                if not os.path.isfile(prefix + suffix):
                        return prefix + suffix
                elif os.path.isfile(prefix + str(ongoingCount) + suffix):
                        ongoingCount += 1
                else:
                        return prefix + str(ongoingCount) + suffix

def properties_size_coords(screenshot_grayscale, template_file, X_OFFSET, Y_OFFSET, threshold=0.9):
        '''
        X_OFFSET should be 15 for size on disk, and 
        Y_OFFSET should be 205 for size on disk, and 
        Some code borrowed from
        https://www.tautvidas.com/blog/2018/02/automating-basic-tasks-in-games-with-opencv-and-python/
        '''
        # Load template file of properties header tabs for recognition
        template = cv2.imread(template_file, 0)
        
        # Run template matching
        res = cv2.matchTemplate(screenshot_grayscale, template, cv2.TM_CCOEFF_NORMED)
        matches = np.where(res >= threshold)
        
        # Validate that pattern matching was successful
        if len(matches[0]) == 0 or len(matches[0]) > 1:
                return False, False # Return two values to not break downstream expectations
        
        # Derive coordinates of properties header tabs
        y_coord, x_coord = matches[0][0], matches[1][0]
        
        # Extrapolate the coordinates of the region which will contain size on disk values
        '''Some attempt is made to scale this extrapolation to the user's
        monitor size; testing was performed on a standard 1080p monitor'''
        monitor = screeninfo.get_monitors()[0]
        disksize_x_topleft = int(x_coord + (X_OFFSET / (1920 / monitor.width)))
        disksize_y_topleft = int(y_coord + (Y_OFFSET / (1080 / monitor.height)))
        return disksize_x_topleft, disksize_y_topleft

def screenshot_preprocess_for_ocr(monitor_object, x_topleft, y_topleft, x_topleft_offset, y_topleft_offset, RESIZE_RATIO, temp_dir):
        '''
        monitor_object relates to the object generated by e.g., screeninfo.get_monitors()[0]
        '''
        BASE_WIDTH_PIXELS = 100 # configured for disk size in properties window
        BASE_HEIGHT_PIXELS = 10
        
        # Take a screenshot within the specified topleft -> bottom right coordinates
        screenshot_item_names = take_screenshot((x_topleft, y_topleft, int(x_topleft_offset / (1920 / monitor_object.width)), int(y_topleft_offset / (1080 / monitor_object.height))))
        
        # Write a temporary file so we can modify it
        temp_filename = temp_file_prefix_gen(os.path.join(temp_dir, 'temp'), '.png')
        cv2.imwrite(temp_filename, screenshot_item_names)
        
        # Load in the temp file and resize it for OCR
        screenshot_temp_image = Image.open(temp_filename)
        resized_screenshot_image = screenshot_temp_image.resize(
            (
                int(BASE_WIDTH_PIXELS / (1920 / monitor_object.width)) * RESIZE_RATIO,
                int(BASE_HEIGHT_PIXELS / (1080 / monitor_object.height)) * RESIZE_RATIO
            ), Image.ANTIALIAS
        )
        resized_screenshot_image.save(temp_filename, 'PNG')
        
        return temp_filename

def properties_sizes_screenshot_to_OCR_pipeline(monitor_object, template_file, RESIZE_RATIO=6):
        # Obtain screenshots and check them for suitability
        screenshot_grayscale = take_screenshot()
        size_x_topleft, size_y_topleft = properties_size_coords(
            screenshot_grayscale, template_file,
            15, 180
        )
        disksize_x_topleft, disksize_y_topleft = properties_size_coords(
            screenshot_grayscale, template_file,
            15, 205
        )
        
        if disksize_x_topleft == False or size_x_topleft == False:
            return False
        
        # Obtain a cropped screenshot of the disk size
        temp_filename = screenshot_preprocess_for_ocr(
            monitor_object,
            disksize_x_topleft,
            disksize_y_topleft,
            300,
            20,
            RESIZE_RATIO,
            os.path.dirname(template_file)
        )
        temp_filename2 = screenshot_preprocess_for_ocr(
            monitor_object,
            size_x_topleft,
            size_y_topleft,
            300,
            20,
            RESIZE_RATIO,
            os.path.dirname(template_file)
        )
        
        # Use OCR to extract text from the cropped, resized screenshot
        diskSize_ocr_text = cv2_tesseract_OCR(temp_filename)
        size_ocr_text = cv2_tesseract_OCR(temp_filename2)
        
        # Clean up temp file and return OCR text
        os.unlink(temp_filename)
        os.unlink(temp_filename2)
        return diskSize_ocr_text, size_ocr_text

def cv2_tesseract_OCR(image_file):
        '''Some code borrowed from 
        https://github.com/AnirudhMergu/TesseractOCR/blob/master/ocr_main.py
        '''
        # Load and preprocess image
        image = cv2.imread(image_file)
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        gray = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)[1]
        # Produce temporary file
        filename = temp_file_prefix_gen(os.path.join(os.path.dirname(image_file), 'temp'), '.png')
        cv2.imwrite(filename, gray)
        # OCR of preprocessed image file
        ocr_text = pytesseract.image_to_string(Image.open(filename))
        # Delete temporary file & return
        os.unlink(filename)
        return ocr_text

def properties_exitButton_coords(template_file, threshold=0.9):
        '''Some code borrowed from
        https://www.tautvidas.com/blog/2018/02/automating-basic-tasks-in-games-with-opencv-and-python/
        '''
        # Obtain a screenshot
        screenshot_grayscale = take_screenshot()
        
        # Load template file of properties header tabs for recognition
        template = cv2.imread(template_file, 0)
        
        # Run template matching
        res = cv2.matchTemplate(screenshot_grayscale, template, cv2.TM_CCOEFF_NORMED)
        matches = np.where(res >= threshold)
        
        # Validate that pattern matching was successful
        if len(matches[0]) == 0 or len(matches[0]) > 1:
            return False, False # Return two values to not break downstream expectations
        
        # Derive coordinates of properties header tabs
        y_coord, x_coord = matches[0][0], matches[1][0]
        
        # Extrapolate the coordinates of the region which will contain the exit button
        '''Some attempt is made to scale this extrapolation to the user's
        monitor size; testing was performed on a standard 1080p monitor'''
        monitor = screeninfo.get_monitors()[0]
        exitButton_x_topleft = int(x_coord + (335 / (1920 / monitor.width)))
        exitButton_y_topleft = int(y_coord + (-30 / (1080 / monitor.height)))
        
        return exitButton_x_topleft, exitButton_y_topleft

## Properties launching
class SHELLEXECUTEINFO(ctypes.Structure):
    _fields_ = (
        ("cbSize",ctypes.wintypes.DWORD),
        ("fMask",ctypes.c_ulong),
        ("hwnd",ctypes.wintypes.HANDLE),
        ("lpVerb",ctypes.c_char_p),
        ("lpFile",ctypes.c_char_p),
        ("lpParameters",ctypes.c_char_p),
        ("lpDirectory",ctypes.c_char_p),
        ("nShow",ctypes.c_int),
        ("hInstApp",ctypes.wintypes.HINSTANCE),
        ("lpIDList",ctypes.c_void_p),
        ("lpClass",ctypes.c_char_p),
        ("hKeyClass",ctypes.wintypes.HKEY),
        ("dwHotKey",ctypes.wintypes.DWORD),
        ("hIconOrMonitor",ctypes.wintypes.HANDLE),
        ("hProcess",ctypes.wintypes.HANDLE),
    )

class PropertiesLauncher:
    SEE_MASK_NOCLOSEPROCESS = 0x00000040
    SEE_MASK_INVOKEIDLIST = 0x0000000C
    
    def __init__(self):
        self.sei = SHELLEXECUTEINFO()
        self.sei.cbSize = ctypes.sizeof(self.sei)
        self.sei.fMask = PropertiesLauncher.SEE_MASK_NOCLOSEPROCESS | PropertiesLauncher.SEE_MASK_INVOKEIDLIST
        self.sei.lpVerb = "properties".encode("utf-8")
        self.sei.nShow = 1
        
        self.ShellExecuteEx = ctypes.windll.shell32.ShellExecuteEx
        self.ShellExecuteEx.restype = ctypes.wintypes.BOOL
    
    def launch_file(self, file):
        self.sei.lpFile = file.encode("utf-8")
        self.ShellExecuteEx(ctypes.byref(self.sei))

## Mouse handling
def mouse_move(coord):
    '''We use ctypes instead of pyautogui since ctypes supports moving the
    mouse across multiple monitors.'''
    ctypes.windll.user32.SetCursorPos(coord[0], coord[1])

def mouse_down(button, seconds=0.5):
    pyautogui.mouseDown(button=button, pause=seconds)

def mouse_up(button, seconds=0.5):
    pyautogui.mouseUp(button=button, pause=seconds)

def mouse_press(button, sleepTime=0.10):
    if button.lower() not in ['left', 'right', 'middle']:
        print('mouse_press: button not recognised; coding error')
        quit()
    mouse_down(button.lower(), 0.2)
    time.sleep(sleepTime)
    mouse_up(button.lower(), 0.1)

## Main pipelining
def get_file_sizes(monitor, templateFile, launcher, file, PROPERTY_SLEEP_TIME=1.0):
    # Move the mouse to a safe position for launching properties window
    mouse_move([100, 100])
    
    # Launch the properties window
    launcher.launch_file(file)
    time.sleep(PROPERTY_SLEEP_TIME)
    
    # Run OCR pipeline to get file size text
    diskSize, size = properties_sizes_screenshot_to_OCR_pipeline(monitor, templateFile)
    
    # Store relevant part of OCR text
    diskSizeBytes = int(diskSize.split(" (")[1].split(" bytes")[0].replace(",", "").replace(" ", "").replace(".", ""))
    sizeBytes = int(size.split(" (")[1].split(" bytes")[0].replace(",", "").replace(" ", "").replace(".", ""))
    
    # Close the properties box
    exitButton_x_topleft, exitButton_y_topleft = properties_exitButton_coords(templateFile)
    
    mouse_move([exitButton_x_topleft, exitButton_y_topleft])
    mouse_press('left')
    
    return diskSizeBytes, sizeBytes

def outliers_z_score(ys, threshold=3):
    """
    Credit to http://colingorrie.github.io/outlier-detection.html
    """
    mean_y = np.mean(ys)
    stdev_y = np.std(ys)
    z_scores = [(y - mean_y) / stdev_y for y in ys]
    return np.where(np.abs(z_scores) > threshold)

def main():
    ## TBD: Args and stuff
    
    homeDir = r"E:\Alexie_data\Alexie"
    sendDir = r"Y:\horti_tree_genomics\Zac_uploads\data_sent_to_alexie"
    
    # Setup property inspector and OCR values
    launcher = PropertiesLauncher()
    templateFile = os.path.join(TEMPLATE_DIR, "properties_tabs.png")
    monitor = screeninfo.get_monitors()[0]
    
    # Setup data storage variables
    "Do it here so I stop resetting things when highlight running it"
    homeSizes = {}
    
    sendSizes = {}
    sendIsBad = []
    
    # Check file properties from home dir
    for dir in os.listdir(homeDir):
        dir = os.path.join(homeDir, dir)
        for file in os.listdir(dir):
            file = os.path.join(dir, file)
            if os.path.basename(file) in homeSizes:
                continue
            
            # Get file size in bytes via OCR pipeline
            while True:
                try:
                    diskSizeBytes, sizeBytes = get_file_sizes(monitor, templateFile, launcher, file)
                    break
                except:
                    # Close the properties box if relevant
                    exitButton_x_topleft, exitButton_y_topleft = properties_exitButton_coords(templateFile)
                    if exitButton_x_topleft != None:
                        mouse_move([exitButton_x_topleft, exitButton_y_topleft])
                        mouse_press('left')
                    continue
            
            # Store results
            homeSizes[os.path.basename(file)] = diskSizeBytes
    
    # Check file properties from send dir
    for dir in os.listdir(sendDir):
        dir = os.path.join(sendDir, dir)
        for file in os.listdir(dir):
            file = os.path.join(dir, file)
            if os.path.basename(file) in sendSizes:
                continue
            
            # Get file size in bytes via OCR pipeline
            while True:
                try:
                    diskSizeBytes, sizeBytes = get_file_sizes(monitor, templateFile, launcher, file)
                    break
                except:
                    # Close the properties box if relevant
                    exitButton_x_topleft, exitButton_y_topleft = properties_exitButton_coords(templateFile)
                    if exitButton_x_topleft != None:
                        mouse_move([exitButton_x_topleft, exitButton_y_topleft])
                        mouse_press('left')
                    continue
            
            # Flag any problems
            if abs(diskSizeBytes - sizeBytes) > 2e6: # more than 2Mb discrepancy
                sendIsBad.append(os.path.basename(file))
            
            # Store results
            sendSizes[os.path.basename(file)] = diskSizeBytes
    
    # Find problem files by comparison of the home and send dirs
    keyOrder = list(homeSizes.keys())
    
    notExisting = [key for key in keyOrder if key not in sendSizes]
    
    amountDiffers = [abs(homeSizes[key] - sendSizes[key]) for key in keyOrder if key in sendSizes]
    outlierIndices = list(outliers_z_score(amountDiffers)[0])
    outliers = [keyOrder[i] for i in outlierIndices]
    
    # Combine all problems together including those from isBad flagging
    problemFiles = set(notExisting).union(set(outliers)).union(sendIsBad)
    
    # Print result and alert that program finished successfully
    print("Problem files:\n{0}".format("\n".join(problemFiles)))
    
    
    

if __name__ == "__main__":
    main()
